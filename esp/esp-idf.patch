diff --git a/components/esp_netif/lwip/netif/wlanif.c b/components/esp_netif/lwip/netif/wlanif.c
index f6bdfae4fa..692a3dde92 100644
--- a/components/esp_netif/lwip/netif/wlanif.c
+++ b/components/esp_netif/lwip/netif/wlanif.c
@@ -114,6 +114,11 @@ static err_t low_level_output(struct netif *netif, struct pbuf *p)
     return ERR_IF;
 }

+__attribute__((weak)) int wlanif_l2_input_hook(uint8_t *buf, int size)
+{
+    return 0;
+}
+
 /**
  * This function should be called when a packet is ready to be read
  * from the interface. It uses the function low_level_input() that
@@ -139,6 +144,11 @@ esp_netif_recv_ret_t wlanif_input(void *h, void *buffer, size_t len, void* l2_bu
         return ESP_NETIF_OPTIONAL_RETURN_CODE(ESP_FAIL);
     }

+    if (wlanif_l2_input_hook(buffer, len)) {
+        esp_netif_free_rx_buffer(esp_netif, l2_buff);
+        return ESP_NETIF_OPTIONAL_RETURN_CODE(ESP_OK);
+    }
+
 #ifdef CONFIG_LWIP_L2_TO_L3_COPY
     p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
     if (p == NULL) {
diff --git a/components/esp_psram/esp_psram.c b/components/esp_psram/esp_psram.c
index daaa2d55e0..3e980e7278 100644
--- a/components/esp_psram/esp_psram.c
+++ b/components/esp_psram/esp_psram.c
@@ -299,6 +299,12 @@ esp_err_t esp_psram_init(void)
     return ESP_OK;
 }

+void *esp_psram_get(size_t *size)
+{
+    *size = s_psram_ctx.regions_to_heap[PSRAM_MEM_8BIT_ALIGNED].size;
+    return (void *) s_psram_ctx.regions_to_heap[PSRAM_MEM_8BIT_ALIGNED].vaddr_start;
+}
+
 esp_err_t esp_psram_extram_add_to_heap_allocator(void)
 {
     esp_err_t ret = ESP_FAIL;
diff --git a/components/esp_hw_support/esp_memory_utils.c b/components/esp_hw_support/esp_memory_utils.c
index a75a769b52..63100e7ab7 100644
--- a/components/esp_hw_support/esp_memory_utils.c
+++ b/components/esp_hw_support/esp_memory_utils.c
@@ -79,7 +79,15 @@ bool esp_ptr_external_ram(const void *p)
     return false;
 #endif  //!SOC_SPIRAM_SUPPORTED
 #if CONFIG_SPIRAM
+    // Workaround for ESP32-P4 region tracking mismatch:
+    // Check against actual SOC PSRAM range instead of tracked regions
+#if CONFIG_IDF_TARGET_ESP32P4
+    intptr_t ip = (intptr_t)p;
+    // PSRAM is mapped at 0x48000000 for 32MB
+    return (ip >= 0x48000000 && ip < 0x4A000000);
+#else
     return esp_psram_check_ptr_addr(p);
+#endif
 #else
     return false;
 #endif  //CONFIG_SPIRAM
diff --git a/components/esp_psram/system_layer/esp_psram.c b/components/esp_psram/system_layer/esp_psram.c
index d80d8498fb..63d4eaf3f5 100644
--- a/components/esp_psram/system_layer/esp_psram.c
+++ b/components/esp_psram/system_layer/esp_psram.c
@@ -401,6 +401,18 @@ esp_err_t esp_psram_init(void)
     return ESP_OK;
 }

+void *esp_psram_get(size_t *size)
+{
+    *size = s_psram_ctx.regions_to_heap[PSRAM_MEM_8BIT_ALIGNED].size;
+    return (void *) s_psram_ctx.regions_to_heap[PSRAM_MEM_8BIT_ALIGNED].vaddr_start;
+}
+
+void esp_psram_get_mapped(void **mapped_start, void **heap_start)
+{
+    *mapped_start = (void *) s_psram_ctx.mapped_regions[PSRAM_MEM_8BIT_ALIGNED].vaddr_start;
+    *heap_start = (void *) s_psram_ctx.regions_to_heap[PSRAM_MEM_8BIT_ALIGNED].vaddr_start;
+}
+
 esp_err_t esp_psram_extram_add_to_heap_allocator(void)
 {
     esp_err_t ret = ESP_FAIL;
